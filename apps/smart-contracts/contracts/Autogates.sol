// SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;

import '@chainlink/contracts/src/v0.8/AutomationCompatible.sol';
import '@chainlink/contracts/src/v0.8/ChainlinkClient.sol';
import '@chainlink/contracts/src/v0.8/ConfirmedOwner.sol';

interface IMintngContractInterface {
    function safeMint(address to, string memory uri) external;
}

contract Autogates is
    AutomationCompatibleInterface,
    ChainlinkClient,
    ConfirmedOwner
{
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;
    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;
    string private gateID;
    bool public approved;

    event RequestVolume(
        bytes32 indexed requestId,
        bool approved,
        string lastChecked
    );
    address private MintingContractAddress =
        0x5cB675e6e9e947A1c40b3F83b673c6A8f803f3B7;
    uint256 public counter;

    address[] public addressesToVerify = [
        0x4269f41Fa8440CdbD1A919eEd9414bF96BDFB5eE,
        0xA4B7CEe8409673624EC9B075f5A4f9b8EbAdEd49
    ];

    mapping(bytes32 => address) private responseID;

    constructor(uint256 updateInterval) ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
        setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
        jobId = 'c1c5e92880894eb6b27d3cae19670aa3';
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        interval = updateInterval;
        lastTimeStamp = block.timestamp;

        counter = 0;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function addAddress(address _newAddress) public {
        addressesToVerify.push(_newAddress);
    }

    function setGate(string memory _newGate) public {
        gateID = _newGate;
    }

    function setMintingContract(address _newContract) public onlyOwner {
        MintingContractAddress = _newContract;
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            batchVerify();
        }

        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    string public lastChecked;

    function batchVerify() public {
        for (uint256 i = 0; i < addressesToVerify.length; i++) {
            address currentWallet = addressesToVerify[i];
            requestVolumeData(currentWallet, gateID);
        }
    }

    function requestVolumeData(address _wallet, string memory _gateId)
        public
        returns (bytes32 requestId)
    {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );
        string memory wallet = string(abi.encodePacked(_wallet));
        string memory gateId = _gateId;
        string memory url = string.concat(
            'https://gates.wtf/api/verify?address=',
            wallet,
            '&gateId=',
            gateId
        );
        // Set the URL to perform the GET request on
        req.add('get', url);
        req.add('path', 'success');
        // Sends the request
        //todo add sendChainlinkRequest(req, fee) and wallet addy to mapping
        bytes32 response = sendChainlinkRequest(req, fee);
        responseID[response] = _wallet;
        return response;
    }

    function fulfill(bytes32 _requestId, bool _approved)
        public
        recordChainlinkFulfillment(_requestId)
    {
        address mintTo = responseID[_requestId];
        if (_approved = true) {
            execute(mintTo);
        }
        emit RequestVolume(_requestId, _approved, lastChecked);
    }

    function execute(address mintTo) internal virtual {
        gainAccess(mintTo);
    }

    function gainAccess(address _newMemb) public {
        IMintngContractInterface(MintingContractAddress).safeMint(
            _newMemb,
            'https://media.istockphoto.com/photos/yellow-rubber-duck-for-bath-time-picture-id185590965?k=20&m=185590965&s=612x612&w=0&h=tXDiN77vzdvGyCuIN3tD8I6kUjA2fNq-dKaVmodXuTA='
        );
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            'Unable to transfer'
        );
    }
}
