// SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import '@chainlink/contracts/src/v0.8/AutomationCompatible.sol';
import '@chainlink/contracts/src/v0.8/ChainlinkClient.sol';
import '@chainlink/contracts/src/v0.8/ConfirmedOwner.sol';
import '@openzeppelin/contracts/utils/Strings.sol';

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
interface IMintngContractInterface {
    function safeMint(address to, string memory uri) external;
}

contract Autogates is
    AutomationCompatibleInterface,
    ChainlinkClient,
    ConfirmedOwner
{
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;
    uint256 private gateID;
    bool public approved;

    event RequestVolume(
        bytes32 indexed requestId,
        bool approved,
        string lastChecked
    );
    address private MintingContractAddress =
        0x5cB675e6e9e947A1c40b3F83b673c6A8f803f3B7;
    uint256 public counter;

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    address[] public addressesToVerify;

    mapping(bytes32 => address) private responseID;

    constructor(uint256 _gateId, uint256 updateInterval)
        ConfirmedOwner(msg.sender)
    {
        setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
        setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
        jobId = 'c1c5e92880894eb6b27d3cae19670aa3';
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        gateID = _gateId;
        counter = 0;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function addAddress(address _newAddress) public {
        addressesToVerify.push(_newAddress);
    }

    function setGate(uint256 _gateId) public onlyOwner {
        gateID = _gateId;
    }

    function setMintingContract(address _newContract) public onlyOwner {
        MintingContractAddress = _newContract;
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            batchVerify();
        }

        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    string public lastChecked;

    function batchVerify() public {
        for (uint256 i = 0; i < addressesToVerify.length; i++) {
            address currentWallet = addressesToVerify[i];
            requestVolumeData(currentWallet, gateID);
        }
    }

    function toAsciiString(address x) internal pure returns (string memory) {
        bytes memory s = new bytes(40);
        for (uint256 i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2 * i] = char(hi);
            s[2 * i + 1] = char(lo);
        }
        return string(s);
    }

    function char(bytes1 b) internal pure returns (bytes1 c) {
        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
        else return bytes1(uint8(b) + 0x57);
    }

    function uintToString(uint256 _value) public pure returns (string memory) {
        bytes32 _bytes = bytes32(_value);
        bytes memory HEX = '0123456789abcdef';
        bytes memory _string = new bytes(42);
        _string[0] = '0';
        _string[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            _string[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];
            _string[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];
        }
        return string(_string);
    }

    function buildUrl(address _wallet, uint256 _gateId)
        public
        view
        returns (string memory)
    {
        return
            string.concat(
                'https://arbi.gates.wtf/api/verify?address=',
                toAsciiString(_wallet),
                '&gateId=',
                Strings.toString(_gateId)
            );
    }

    function requestVolumeData(address _wallet, uint256 _gateId)
        public
        returns (bytes32 requestId)
    {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );
        string memory url = buildUrl(_wallet, _gateId);
        // Set the URL to perform the GET request on
        req.add('get', url);
        req.add('path', 'success');
        // Sends the request
        //todo add sendChainlinkRequest(req, fee) and wallet addy to mapping
        bytes32 response = sendChainlinkRequest(req, fee);
        responseID[response] = _wallet;
        return response;
    }

    function fulfill(bytes32 _requestId, bool _approved)
        public
        recordChainlinkFulfillment(_requestId)
    {
        address mintTo = responseID[_requestId];
        if (_approved = true) {
            execute(mintTo);
        }
        emit RequestVolume(_requestId, _approved, lastChecked);
    }

    function execute(address mintTo) internal virtual {
        gainAccess(mintTo);
    }

    function gainAccess(address _newMemb) public {
        IMintngContractInterface(MintingContractAddress).safeMint(
            _newMemb,
            'https://media.istockphoto.com/photos/yellow-rubber-duck-for-bath-time-picture-id185590965?k=20&m=185590965&s=612x612&w=0&h=tXDiN77vzdvGyCuIN3tD8I6kUjA2fNq-dKaVmodXuTA='
        );
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            'Unable to transfer'
        );
    }
}
