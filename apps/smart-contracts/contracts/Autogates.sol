// SPDX-License-Identifier: MIT
pragma solidity 0.8.14;

import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";
import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";


interface IMintngContractInterface {
  function safeMint(address to, string memory uri) external;
  
}
contract Autogates is AutomationCompatibleInterface, ChainlinkClient, ConfirmedOwner  {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;
    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    event RequestVolume(bytes32 indexed requestId, bool approved, string lastChecked);
    address private  MintingContractAddress = 0x5cB675e6e9e947A1c40b3F83b673c6A8f803f3B7;
    uint public counter;

    address[] public addressesToVerify = [0x4269f41Fa8440CdbD1A919eEd9414bF96BDFB5eE, 0xA4B7CEe8409673624EC9B075f5A4f9b8EbAdEd49];

    mapping(bytes32=> address) private responseID;

     constructor(uint updateInterval) ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
        setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
        jobId = "c1c5e92880894eb6b27d3cae19670aa3";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        interval = updateInterval;
      lastTimeStamp = block.timestamp;

      counter = 0;
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            batchVerify();
        }
       
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    string public lastChecked;

    function batchVerify() public{
        for (uint i = 0; i < addressesToVerify.length; i++ ){
        address currentWallet = addressesToVerify[i];
        requestVolumeData(currentWallet, "47");
        }
    }

    function requestVolumeData(address _wallet, string memory _gateId) public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
        string memory wallet = string(abi.encodePacked(_wallet));
        string memory  gateId = _gateId;
        string memory url = string.concat("https://gates.wtf/api/verify?address=",wallet, "&gateId=",gateId );
        // Set the URL to perform the GET request on
        req.add("get", url);
        req.add("path", "success");
        // Sends the request
        //todo add sendChainlinkRequest(req, fee) and wallet addy to mapping 
        bytes32 response = sendChainlinkRequest(req, fee);
        responseID[response] =_wallet;
        return response;
    }

  bool public approved;
function fulfill(bytes32 _requestId, bool _approved) public recordChainlinkFulfillment(_requestId) {
  approved = _approved;
  address mintTo = responseID[_requestId];
  if(approved = true){

      IMintngContractInterface(MintingContractAddress).safeMint(mintTo, "sometestURI");
  }
  //todo logic  if  _approved get wallet id by requestId then mint by wallet addres
  //interface goes here
  emit RequestVolume(_requestId, _approved, lastChecked);
}
function execute() virtual private {

}

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
    }




}
